## 1 题目分析

题目要求接受输入两个正整数

求最大公约数与最小公倍数

## 2 实现思路

1. 将最大公约数与最小公倍数设为两个类：
   ```
   CP_GreatestCommonDivisor
   CP_LowestCommonMultiple
   ```

2. 类CP_GreatestCommonDivisor用于求最大公约数
   ```
   class CP_GreatestCommonDivisor
    {
    public:
        CP_GreatestCommonDivisor(long long a, long long b);
        ~CP_GreatestCommonDivisor();

        long long mb_getGCD();

    private:
        long long m_a;
        long long m_b;
        long long m_GCD;
    };
   ```
   * 构造函数中对成员变量 m_a, m_b 进行初始化
   * 成员函数 mb_getGCD() 进行最大公约数计算，具体算法见“4 算法模型”
   * 成员变量 m_GCD 中存储计算最大公约数结果

3. 类CP_LowestCommonMultipler用于求最小公倍数，结构与2类似

4. 在CP_GCDAndLCMMain.cpp中通过主函数接受输入，通过new实例化对象，进行最小公约数与最大公倍数的计算。

5. CP_Define.h 中包含无需改动的代码体。结合 CP_Define.cpp pch.h pch.cpp 实现预编译，加快后续编译速度。

6. 头文件中都含有 #progma once 指令，保证头文件只被编译一次。

## 3 代码运行方法

 平台：Visual Studio 2022

 x64 release

## 4 算法模型

### 最大公约数

通过辗转相除法求出两个整数的最大公约数

设两个整数为a,b，且a>b，a%b = r, 当 r != 0 时，(a,b) = (b,r)。

具体实现代码：
```
long long CP_GreatestCommonDivisor::mb_getGCD()
{
	long long a = m_a > m_b ? m_a : m_b;
	long long b = m_a > m_b ? m_b : m_a;
	long long r = a % b;

	while (r != 0)
	{
		a = b;
		b = r;
		r = a % b;
	}

	m_GCD = b; // 余数为0时，b即为所求
	return m_GCD;
}
```

* 参与计算的数据类型都为long long，减少了一些溢出的问题

### 最小公倍数

设两个整数为a,b，最大公约数为GCD，最小公倍数为LCM，则 LCM = a*b / GCD

具体实现代码：
```
long long CP_LowestCommonMultiple::mb_getLCM(long long GCD)
{
	m_LCM = m_a * (m_b / GCD);
	return m_LCM;
}
```

* 其中先计算 （m_b/GCD），减小数字量级，减少一些溢出的问题

## 5 测试报告

测试思路：选取普通情况、数字较大情况、相等情况、互质情况、一数字为另一数字倍数、输入非正整数等特殊情况进行测试

1. 正常输入
   ```
    请输入两个正整数：
    12345 54321
    12345和54321的最大公约数为：3
    12345和54321的最小公倍数为：223530915
    请按任意键继续. . .
   ```

2. 输入较大正整数 + 一数字为另一数字倍数
   ```
    请输入两个正整数：
    1000000000000 5000000000
    1000000000000和5000000000的最大公约数为：5000000000
    1000000000000和5000000000的最小公倍数为：1000000000000
    请按任意键继续. . .
   ```

3. 输入相等的两个正整数
   ```
    请输入两个正整数：
    2023012175 2023012175
    2023012175和2023012175的最大公约数为：2023012175
    2023012175和2023012175的最小公倍数为：2023012175
    请按任意键继续. . .
   ```

4. 输入互质的两个正整数
   ```
    请输入两个正整数：
    23 47
    23和47的最大公约数为：1
    23和47的最小公倍数为：1081
    请按任意键继续. . .
   ```

5. 输入非正整数
   ```
    请输入两个正整数：
    0 -100
    您输入的数字不是正整数
    请按任意键继续. . .
   ```

## 6 提高部分

### 6.1 自动测试验证

在最大公约数类中，添加成员函数mb_isGCD();
在最小公倍数类中，添加成员函数mb_isLCM()

#### 验证算法思路

1. 验证最大公约数

   首先判断成员变量 m_GCD 是否为 m_a 和 m_b 的公因数

   在 m_GCD 是两数共因数的情况下，从小到大遍历 m_GCD 的正整数倍，直到该倍数大于两数中较小的一个。如果 m_GCD 的倍数中有两数的公约数，则其不是两数的最大公约数。

2. 验证最小公倍数

   首先判断首先判断成员变量 m_LCM 是否为 m_a 和 m_b 的公倍数

   在 m_LCM 是 m_a 和 m_b 的公倍数的情况下，遍历两数中较大的一个的整数倍，直到 m_LCM。若其中有两数的公倍数，则 m_LCM 不是最小公倍数。

#### 验证分析

由于遍历的完备性，该验证充分有效。

验证实测
```
请输入两个正整数：
2461235552 3238
2461235552和3238的最大公约数为：2
2461235552和3238的最小公倍数为：3984740358688

————————验证————————
2是2461235552和3238的最大公约数
3984740358688是2461235552和3238的最小公倍数

请按任意键继续. . .
```

6.2 思考：如何提高本作业的代码质量

在计算最小公倍数时，依赖于最大公约数的计算结果。

代码中可以改进的地方：可以采用后续课程学习的内容，将GCD类中的计算结果共享给LCM类。
